/**
 * Meta Generator - Auto-generate SEO meta tags
 * Zero-Config SEO implementation
 */

import { SEO_LIMITS, PRIMARY_KEYWORD, AutoGeneratedMeta } from '../../types/article';

/**
 * Extract first paragraph from markdown content
 */
function extractFirstParagraph(content: string): string {
  if (!content) return '';

  // Remove markdown headers
  let text = content.replace(/^#{1,6}\s+.+$/gm, '');

  // Remove markdown formatting
  text = text
    .replace(/\*\*(.+?)\*\*/g, '$1') // Bold
    .replace(/\*(.+?)\*/g, '$1') // Italic
    .replace(/\[(.+?)\]\(.+?\)/g, '$1') // Links
    .replace(/`(.+?)`/g, '$1') // Code
    .trim();

  // Get first non-empty paragraph
  const paragraphs = text.split('\n\n').filter(p => p.trim().length > 0);

  return paragraphs[0] || '';
}

/**
 * Optimize title for SEO with keyword
 */
export function optimizeTitle(title: string, keyword: string = PRIMARY_KEYWORD): string {
  if (!title) return '';

  let optimized = title.trim();

  // Check if keyword is already in title
  const hasKeyword = optimized.toLowerCase().includes(keyword.toLowerCase());

  // If keyword not in title and there's room, add it naturally
  if (!hasKeyword && (optimized.length + keyword.length + 3) <= SEO_LIMITS.TITLE_OPTIMAL) {
    // Try to add at beginning for better SEO
    optimized = `${keyword}: ${optimized}`;
  }

  // Truncate if too long
  if (optimized.length > SEO_LIMITS.TITLE_MAX) {
    optimized = optimized.substring(0, SEO_LIMITS.TITLE_OPTIMAL).trim();
    // Try to cut at word boundary
    const lastSpace = optimized.lastIndexOf(' ');
    if (lastSpace > 30) {
      optimized = optimized.substring(0, lastSpace);
    }
    optimized += '...';
  }

  return optimized;
}

/**
 * Generate meta description from content
 */
export function generateMetaDescription(
  content: string,
  excerpt?: string,
  keyword: string = PRIMARY_KEYWORD
): string {
  // Prefer excerpt if available
  let description = excerpt || extractFirstParagraph(content);

  if (!description) return '';

  // Clean and trim
  description = description.trim();

  // Add keyword if not present and there's room
  const hasKeyword = description.toLowerCase().includes(keyword.toLowerCase());
  if (!hasKeyword && (description.length + keyword.length + 10) <= SEO_LIMITS.DESCRIPTION_OPTIMAL) {
    // Add keyword naturally at the beginning
    description = `เกี่ยวกับ${keyword}: ${description}`;
  }

  // Truncate if too long
  if (description.length > SEO_LIMITS.DESCRIPTION_MAX) {
    description = description.substring(0, SEO_LIMITS.DESCRIPTION_OPTIMAL).trim();
    // Try to cut at sentence boundary
    const lastPeriod = description.lastIndexOf('.');
    const lastSpace = description.lastIndexOf(' ');

    if (lastPeriod > 80) {
      description = description.substring(0, lastPeriod + 1);
    } else if (lastSpace > 80) {
      description = description.substring(0, lastSpace) + '...';
    } else {
      description += '...';
    }
  }

  // Ensure minimum length
  if (description.length < SEO_LIMITS.DESCRIPTION_MIN) {
    // Try to add more from content
    const secondParagraph = content.split('\n\n')[1];
    if (secondParagraph && (description.length + secondParagraph.length) <= SEO_LIMITS.DESCRIPTION_MAX) {
      description += ' ' + secondParagraph.trim();
    }
  }

  return description;
}

/**
 * Validate title length and quality
 */
export function validateTitle(title: string): {
  valid: boolean;
  length: number;
  optimal: boolean;
  issues: string[];
  score: number; // 0-100
} {
  const issues: string[] = [];
  const length = title.length;
  let score = 100;

  if (length === 0) {
    issues.push('กรุณาระบุหัวข้อ');
    return { valid: false, length, optimal: false, issues, score: 0 };
  }

  if (length < SEO_LIMITS.TITLE_MIN) {
    issues.push(`หัวข้อสั้นเกินไป (${length} ตัวอักษร) ควรมีอย่างน้อย ${SEO_LIMITS.TITLE_MIN} ตัวอักษร`);
    score -= 30;
  }

  if (length > SEO_LIMITS.TITLE_MAX) {
    issues.push(`หัวข้อยาวเกินไป (${length} ตัวอักษร) จะถูกตัดในผลค้นหา (แนะนำ ${SEO_LIMITS.TITLE_OPTIMAL} ตัวอักษร)`);
    score -= 20;
  }

  const optimal = length >= SEO_LIMITS.TITLE_MIN && length <= SEO_LIMITS.TITLE_OPTIMAL;

  if (!optimal && length <= SEO_LIMITS.TITLE_MAX) {
    issues.push('ความยาวใช้ได้ แต่ยังไม่เหมาะสมที่สุด');
    score -= 10;
  }

  // Check for keyword
  const hasKeyword = title.toLowerCase().includes(PRIMARY_KEYWORD.toLowerCase());
  if (!hasKeyword) {
    issues.push(`ควรเพิ่มคีย์เวิร์ด "${PRIMARY_KEYWORD}" ในหัวข้อ`);
    score -= 15;
  }

  // Check for numbers (often good for SEO)
  const hasNumbers = /\d+/.test(title);
  if (hasNumbers) {
    score += 5; // Bonus
  }

  // Check for power words
  const powerWords = ['คู่มือ', 'เทคนิค', 'วิธี', 'แนะนำ', 'สูตร', 'ฟรี', 'ง่าย'];
  const hasPowerWords = powerWords.some(word => title.includes(word));
  if (hasPowerWords) {
    score += 5; // Bonus
  }

  return {
    valid: issues.length === 0 || (length > 0 && length <= SEO_LIMITS.TITLE_MAX),
    length,
    optimal,
    issues,
    score: Math.max(0, Math.min(100, score))
  };
}

/**
 * Validate description length and quality
 */
export function validateDescription(description: string): {
  valid: boolean;
  length: number;
  optimal: boolean;
  issues: string[];
  score: number; // 0-100
} {
  const issues: string[] = [];
  const length = description.length;
  let score = 100;

  if (length === 0) {
    issues.push('กรุณาระบุคำอธิบาย');
    return { valid: false, length, optimal: false, issues, score: 0 };
  }

  if (length < SEO_LIMITS.DESCRIPTION_MIN) {
    issues.push(`คำอธิบายสั้นเกินไป (${length} ตัวอักษร) ควรมีอย่างน้อย ${SEO_LIMITS.DESCRIPTION_MIN} ตัวอักษร`);
    score -= 30;
  }

  if (length > SEO_LIMITS.DESCRIPTION_MAX) {
    issues.push(`คำอธิบายยาวเกินไป (${length} ตัวอักษร) จะถูกตัดในผลค้นหา (แนะนำ ${SEO_LIMITS.DESCRIPTION_OPTIMAL} ตัวอักษร)`);
    score -= 20;
  }

  const optimal = length >= SEO_LIMITS.DESCRIPTION_MIN && length <= SEO_LIMITS.DESCRIPTION_OPTIMAL;

  if (!optimal && length <= SEO_LIMITS.DESCRIPTION_MAX) {
    issues.push('ความยาวใช้ได้ แต่ยังไม่เหมาะสมที่สุด');
    score -= 10;
  }

  // Check for keyword
  const hasKeyword = description.toLowerCase().includes(PRIMARY_KEYWORD.toLowerCase());
  if (!hasKeyword) {
    issues.push(`ควรเพิ่มคีย์เวิร์ด "${PRIMARY_KEYWORD}" ในคำอธิบาย`);
    score -= 15;
  }

  // Check for call-to-action
  const ctaWords = ['อ่าน', 'เรียนรู้', 'ดู', 'ค้นพบ', 'แนะนำ'];
  const hasCTA = ctaWords.some(word => description.includes(word));
  if (hasCTA) {
    score += 5; // Bonus
  }

  return {
    valid: issues.length === 0 || (length > 0 && length <= SEO_LIMITS.DESCRIPTION_MAX),
    length,
    optimal,
    issues,
    score: Math.max(0, Math.min(100, score))
  };
}

/**
 * Auto-generate all meta tags
 */
export function autoGenerateMeta(
  title: string,
  content: string,
  excerpt?: string,
  keywords?: string[]
): AutoGeneratedMeta {
  const startTime = Date.now();

  const generatedTitle = optimizeTitle(title);
  const generatedDescription = generateMetaDescription(content, excerpt);
  const generatedKeywords = keywords || extractKeywordsSimple(title + ' ' + content);

  const titleValidation = validateTitle(generatedTitle);
  const descValidation = validateDescription(generatedDescription);

  // Calculate confidence score
  const confidence = Math.round((titleValidation.score + descValidation.score) / 2);

  const processingTime = Date.now() - startTime;

  return {
    title: generatedTitle,
    description: generatedDescription,
    keywords: generatedKeywords,
    generatedAt: new Date().toISOString(),
    confidence,
  };
}

/**
 * Simple keyword extraction (basic implementation)
 * For more advanced, consider using NLP library
 */
function extractKeywordsSimple(text: string, maxKeywords: number = 5): string[] {
  if (!text) return [];

  // Remove markdown and special characters
  const cleaned = text
    .replace(/[#*_`\[\]()]/g, '')
    .toLowerCase();

  // Split into words
  const words = cleaned.split(/\s+/);

  // Thai/English stop words (basic list)
  const stopWords = new Set([
    'และ', 'ที่', 'ใน', 'ของ', 'เป็น', 'การ', 'ได้', 'มี', 'จะ', 'ไป',
    'the', 'is', 'at', 'which', 'on', 'a', 'an', 'as', 'are', 'was', 'were',
  ]);

  // Count word frequency (exclude stop words and short words)
  const wordFreq = new Map<string, number>();

  words.forEach(word => {
    if (word.length > 2 && !stopWords.has(word)) {
      wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
    }
  });

  // Sort by frequency
  const sorted = Array.from(wordFreq.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, maxKeywords)
    .map(([word]) => word);

  // Always include primary keyword if not in list
  if (!sorted.includes(PRIMARY_KEYWORD.toLowerCase())) {
    sorted.unshift(PRIMARY_KEYWORD);
  }

  return sorted.slice(0, maxKeywords);
}
